## create NODES and LINKS for sankey diagram
# names
src_names <- paste0(transitions_df$year_from, "_", transitions_df$from_class)
tgt_names <- paste0(transitions_df$year_to,   "_", transitions_df$to_class)
src_names <- paste0(transitions_df$from_class)
tgt_names <- paste0(transitions_df$to_class)
node_names <- unique(c(src_names, tgt_names))
# df for nodes
nodes <- data.frame(name = node_names, stringsAsFactors = FALSE)
nodes$year  <- as.integer(substr(nodes$name, 1, 4)) # extract year
nodes$class <- as.integer(sub(".*_(\\d+)$", "\\1", nodes$name)) # extract class
# sort: year ascending, class 21→27 (but some of them are absent)
desired_order <- 21:27
nodes$class_rank <- match(nodes$class, desired_order) # define desired order of classes within nodes df
nodes <- nodes[order(nodes$year, nodes$class_rank, nodes$class), ] # sort
nodes$id <- seq_len(nrow(nodes)) - 1
nodes$node_group <- factor(as.character(nodes$class),
levels = as.character(desired_order))
nodes <- nodes[, c("name", "id", "node_group")]
# LINKS
links <- transitions_df |>
mutate(source_name = paste0(year_from, "_", from_class),
target_name = paste0(year_to,   "_", to_class)) |>
left_join(nodes[, c("name","id")], by = c("source_name" = "name")) |>
rename(source = id) |>
left_join(nodes[, c("name","id")], by = c("target_name" = "name")) |>
rename(target = id) |>
transmute(
source,
target,
count,
year_from,
year_to,
from_class,
to_class,
link_group = factor(from_class, levels = desired_order)  # for link color
)
# set limit for senkey
hist(links$count, breaks = 20)
min_count_for_sankey <- 1000
if (min_count_for_sankey > 0) {
links <- links |> filter(count >= min_count_for_sankey)
}
min_count_for_nodes <- 1000
if (min_count_for_nodes > 0) {
# spočítej součet hodnot pro každý uzel
node_strength <- links %>%
group_by(source) %>%
summarise(total_out = sum(count), .groups = "drop") %>%
full_join(
links %>% group_by(target) %>%
summarise(total_in = sum(count), .groups = "drop"),
by = c("source" = "target")
) %>%
mutate(id = source,
total = rowSums(across(c(total_out, total_in)), na.rm = TRUE)) %>%
select(id, total)
keep_nodes <- node_strength %>%
filter(total >= min_count_for_nodes) %>%
pull(id)
# vyfiltruj nodes a links
nodes <- nodes %>% filter(id %in% keep_nodes)
links <- links %>% filter(source %in% keep_nodes, target %in% keep_nodes)
# přečísluj id od nuly
id_map <- setNames(seq_len(nrow(nodes)) - 1, nodes$id)
nodes$id <- unname(id_map[as.character(nodes$id)])
links$source <- unname(id_map[as.character(links$source)])
links$target <- unname(id_map[as.character(links$target)])
}
# colors
class_levels <- as.character(desired_order)
palette_classes <- c("steelblue", "orange", "firebrick", "grey", "deeppink2", "forestgreen", "darkorchid")
palette_classes <- rep(palette_classes, length.out = length(class_levels)) # if more classes than colors
colourScale_js <- htmlwidgets::JS(
sprintf(
"d3.scaleOrdinal().domain(%s).range(%s)",
jsonlite::toJSON(class_levels),
jsonlite::toJSON(palette_classes)
)
)
# sankey creation
sankey <- networkD3::sankeyNetwork(
Links = links,
Nodes = nodes,
Source = "source",
Target = "target",
Value  = "count",
NodeID = "name",
NodeGroup = "node_group",   # NODES: color = group
LinkGroup = "link_group",   # LINKS: color = group of source
colourScale = colourScale_js,
fontSize = 12,
nodeWidth = 26,
nodePadding = 10,
sinksRight = FALSE,
iterations = 0 # !!! to keep desired order
)
## create NODES and LINKS for sankey diagram
# names
src_names <- paste0(transitions_df$year_from, "_", transitions_df$from_class)
tgt_names <- paste0(transitions_df$year_to,   "_", transitions_df$to_class)
node_names <- unique(c(src_names, tgt_names))
# df for nodes
nodes <- data.frame(name = node_names, stringsAsFactors = FALSE)
nodes$year  <- as.integer(substr(nodes$name, 1, 4)) # extract year
nodes$class <- as.integer(sub(".*_(\\d+)$", "\\1", nodes$name)) # extract class
# sort: year ascending, class 21→27 (but some of them are absent)
desired_order <- 21:27
nodes$class_rank <- match(nodes$class, desired_order) # define desired order of classes within nodes df
nodes <- nodes[order(nodes$year, nodes$class_rank, nodes$class), ] # sort
nodes$id <- seq_len(nrow(nodes)) - 1
nodes$node_group <- factor(as.character(nodes$class),
levels = as.character(desired_order))
nodes <- nodes[, c("name", "id", "node_group")]
# LINKS
links <- transitions_df |>
mutate(source_name = paste0(year_from, "_", from_class),
target_name = paste0(year_to,   "_", to_class)) |>
left_join(nodes[, c("name","id")], by = c("source_name" = "name")) |>
rename(source = id) |>
left_join(nodes[, c("name","id")], by = c("target_name" = "name")) |>
rename(target = id) |>
transmute(
source,
target,
count,
year_from,
year_to,
from_class,
to_class,
link_group = factor(from_class, levels = desired_order)  # for link color
)
# set limit for senkey
hist(links$count, breaks = 20)
min_count_for_sankey <- 1000
if (min_count_for_sankey > 0) {
links <- links |> filter(count >= min_count_for_sankey)
}
min_count_for_nodes <- 1000
if (min_count_for_nodes > 0) {
# spočítej součet hodnot pro každý uzel
node_strength <- links %>%
group_by(source) %>%
summarise(total_out = sum(count), .groups = "drop") %>%
full_join(
links %>% group_by(target) %>%
summarise(total_in = sum(count), .groups = "drop"),
by = c("source" = "target")
) %>%
mutate(id = source,
total = rowSums(across(c(total_out, total_in)), na.rm = TRUE)) %>%
select(id, total)
keep_nodes <- node_strength %>%
filter(total >= min_count_for_nodes) %>%
pull(id)
# vyfiltruj nodes a links
nodes <- nodes %>% filter(id %in% keep_nodes)
links <- links %>% filter(source %in% keep_nodes, target %in% keep_nodes)
# přečísluj id od nuly
id_map <- setNames(seq_len(nrow(nodes)) - 1, nodes$id)
nodes$id <- unname(id_map[as.character(nodes$id)])
links$source <- unname(id_map[as.character(links$source)])
links$target <- unname(id_map[as.character(links$target)])
}
# colors
class_levels <- as.character(desired_order)
palette_classes <- c("steelblue", "orange", "firebrick", "grey", "deeppink2", "forestgreen", "darkorchid")
palette_classes <- rep(palette_classes, length.out = length(class_levels)) # if more classes than colors
colourScale_js <- htmlwidgets::JS(
sprintf(
"d3.scaleOrdinal().domain(%s).range(%s)",
jsonlite::toJSON(class_levels),
jsonlite::toJSON(palette_classes)
)
)
# sankey creation
sankey <- networkD3::sankeyNetwork(
Links = links,
Nodes = nodes,
Source = "source",
Target = "target",
Value  = "count",
NodeID = "name",
NodeGroup = "node_group",   # NODES: color = group
LinkGroup = "link_group",   # LINKS: color = group of source
colourScale = colourScale_js,
fontSize = 12,
nodeWidth = 26,
nodePadding = 10,
sinksRight = FALSE,
iterations = 0 # !!! to keep desired order
)
# plot and save
sankey
?unname
### data prep
## libraries
source("scripts/knihovnik.R")
knihovnik(c("terra", "sf", "caret", "pROC"))
## load data
pred_2023 <- rast("Praded/EUGW_data/CZ_CON_CON_78422_20230101_20231231_GTYH_CLASS.tif")
# check
plot(pred_2023)
## buffer and crop rasters
buff <- vect("data/evl_buff1000.gpkg") # old qgis created layer
buff <- project(buff, crs(pred_2023)) # to EPSG 3035
# split to separete N2K sites
# buffMM <- buff[buff$SITECODE == "CZ0214006"]
buffP <- buff[buff$SITECODE == "CZ0714077"]
# crop original raster by buffered N2K site
pred_2023_croped <- crop(pred_2023, buffP, snap = "in", mask = T)
# check
plot(pred_2023_croped)
## convert validation data information to grassland type code
GT_char <- c("Dry grassland",
"Mesic grassland",
"Wet and seasonally wet grassland",
"Alpine and sub-alpine grassland",
"Forest clearings",
"Inland salt steppes",
"Sparsely wooded grassland"
)
GT_code <- 21:27
### stability map
# load rasters
files_class <- list.files(
path = "Praded/EUGW_data/",
pattern = "CLASS\\.tif$",
full.names = TRUE
)
files_class <- sort(files_class)
all_class_rasters <- rast(files_class)
# crop rasters
all_class_rasters <- crop(all_class_rasters, buffP, snap = "in", mask = T)
# rename rasters by years
years <- substr(basename(files_class), 18, 21)
names(all_class_rasters) <- years
## binary stability ‒ where class does not change through years
stable <- app(all_class_rasters, fun = function(x) all(x == x[1])) # all values same?
plot(stable, main="Stable (TRUE) vs Changed (FALSE)")
writeRaster(stable, "data/out/stable_pixels_Praded.tif")
## number of changes through years
nchanges <- app(all_class_rasters, fun = function(x) sum(diff(x) != 0))
plot(nchanges, main="Number of changes (2016–2023)")
writeRaster(nchanges, "data/out/Nchanges_per_pixel_Praded.tif")
source("scripts/knihovnik.R")
co <- c("terra", "dplyr", "stringr", "tidyr", "networkD3", "htmlwidgets")
knihovnik(co)
# data path
dir <- "Praded/EUGW_data/"
# load resters and sort them
files_class <- list.files(
path = dir,
pattern = "CLASS\\.tif$",
full.names = TRUE
) %>% sort()
if (length(files_class) < 2) stop("ERROR: Less than 2 rasters found. At least 2 needed for transition matrix!")
# extract year from raster file name
extract_year <- function(x) {
m <- str_match(basename(x), "_(\\d{8})_")
if (is.na(m[1,2])) NA_character_ else substr(m[1,2], 1, 4)
}
years <- vapply(files_class, extract_year, character(1))
if (any(is.na(years))) stop("For some files year identification failed!")
# create raster stack
r_stack <- rast(files_class)
names(r_stack) <- years
## pairwise transition matrix between years
# prepare empty list
pairwise_list <- vector("list", nlyr(r_stack) - 1)
# loop, which extracts pairwise trtansition matrix
# each time starting year is selected and compared to year+1
for (i in 1:(nlyr(r_stack) - 1)) {
r_from <- r_stack[[i]]
r_to   <- r_stack[[i + 1]]
# twin raster is created
rr <- c(r_from, r_to)
names(rr) <- c("from_class", "to_class")
# extract possible cell values combinations, drop NA
df <- terra::as.data.frame(rr, na.rm = TRUE)
# in case of EUGW, we are only interested in valuse from 21 to 27 (anyway there are no other values, except NA)
df <- df |>
filter(from_class %in% 21:27, to_class %in% 21:27)
# lets count number of pixels in each transition cathegory
ct <- df |>
count(from_class, to_class, name = "count") |>
mutate(year_from = names(r_stack)[i],
year_to   = names(r_stack)[i + 1])
pairwise_list[[i]] <- ct
# rubbish, gc
rm(r_from, r_to, rr, df, ct)
gc()
}
transitions_df <- bind_rows(pairwise_list)
rm(pairwise_list)
## create NODES and LINKS for sankey diagram
# names
src_names <- paste0(transitions_df$year_from, "_", transitions_df$from_class)
tgt_names <- paste0(transitions_df$year_to,   "_", transitions_df$to_class)
node_names <- unique(c(src_names, tgt_names))
# df for nodes
nodes <- data.frame(name = node_names, stringsAsFactors = FALSE)
nodes$year  <- as.integer(substr(nodes$name, 1, 4)) # extract year
nodes$class <- as.integer(sub(".*_(\\d+)$", "\\1", nodes$name)) # extract class
# sort: year ascending, class 21→27 (but some of them are absent)
desired_order <- 21:27
nodes$class_rank <- match(nodes$class, desired_order) # define desired order of classes within nodes df
nodes <- nodes[order(nodes$year, nodes$class_rank, nodes$class), ] # sort
nodes$id <- seq_len(nrow(nodes)) - 1
nodes$node_group <- factor(as.character(nodes$class),
levels = as.character(desired_order))
nodes <- nodes[, c("name", "id", "node_group")]
# LINKS
links <- transitions_df |>
mutate(source_name = paste0(year_from, "_", from_class),
target_name = paste0(year_to,   "_", to_class)) |>
left_join(nodes[, c("name","id")], by = c("source_name" = "name")) |>
rename(source = id) |>
left_join(nodes[, c("name","id")], by = c("target_name" = "name")) |>
rename(target = id) |>
transmute(
source,
target,
count,
year_from,
year_to,
from_class,
to_class,
link_group = factor(from_class, levels = desired_order)  # for link color
)
## set limit for senkey
# links
min_count_for_sankey <- 1000
if (min_count_for_sankey > 0) {
links <- links |> filter(count >= min_count_for_sankey) # filter links with lower count than x
}
min_count_for_nodes <- 1000
if (min_count_for_nodes > 0) {
# compute count for each nod
node_strength <- links %>%
group_by(source) %>%
summarise(total_out = sum(count), .groups = "drop") %>%
full_join(
links %>% group_by(target) %>%
summarise(total_in = sum(count), .groups = "drop"),
by = c("source" = "target")
) %>%
mutate(id = source,
total = rowSums(across(c(total_out, total_in)), na.rm = TRUE)) %>%
select(id, total)
keep_nodes <- node_strength %>%
filter(total >= min_count_for_nodes) %>%
pull(id)
# filter nodes and their
nodes <- nodes %>% filter(id %in% keep_nodes)
links <- links %>% filter(source %in% keep_nodes, target %in% keep_nodes)
# resample IDs
id_map <- setNames(seq_len(nrow(nodes)) - 1, nodes$id)
nodes$id <- unname(id_map[as.character(nodes$id)])
links$source <- unname(id_map[as.character(links$source)])
links$target <- unname(id_map[as.character(links$target)])
}
# colors
class_levels <- as.character(desired_order)
palette_classes <- c("steelblue", "orange", "firebrick", "grey", "deeppink2", "forestgreen", "darkorchid")
palette_classes <- rep(palette_classes, length.out = length(class_levels)) # if more classes than colors
colourScale_js <- htmlwidgets::JS(
sprintf(
"d3.scaleOrdinal().domain(%s).range(%s)",
jsonlite::toJSON(class_levels),
jsonlite::toJSON(palette_classes)
)
)
# sankey creation
sankey <- networkD3::sankeyNetwork(
Links = links,
Nodes = nodes,
Source = "source",
Target = "target",
Value  = "count",
NodeID = "name",
NodeGroup = "node_group",   # NODES: color = group
LinkGroup = "link_group",   # LINKS: color = group of source
colourScale = colourScale_js,
fontSize = 12,
nodeWidth = 26,
nodePadding = 10,
sinksRight = FALSE,
iterations = 0 # !!! to keep desired order
)
# plot and save
sankey
saveWidget(sankey, file = "data/out/sankey_Praded.html", selfcontained = TRUE)
knihovnik <- function(...) {
# převezme jména balíčků jako text
kniha <- as.character(substitute(list(...)))[-1L]
# vyfiltruje nenainstalované balíčky
not_installed <- kniha[!(kniha %in% installed.packages()[, "Package"])]
if (length(not_installed) > 0) {
cat("Not installed packages:\n")
cat(paste("-", not_installed), sep = "\n")
cat("Install them now?? [y/n]: ")
response <- tolower(readline())
if (!response %in% c("y", "yes")) {
return(cat("Cancelled.\n"))
}
install.packages(not_installed, dependencies = TRUE)
}
# načte všechny balíčky
for (kapitola in kniha) {
suppressPackageStartupMessages(library(kapitola, character.only = TRUE))
cat("DONE", kapitola, "\n")
}
}
knihovnik(terra, dplyr, xxs)
knihovnik <- function(...) {
# převezme jména balíčků jako text
kniha <- as.character(substitute(list(...)))[-1L]
# zjistí, které balíčky na CRAN vůbec existují
dostupne <- rownames(available.packages())
neexistujici <- kniha[!(kniha %in% dostupne)]
if (length(neexistujici) > 0) {
stop("Balíček(y) neexistují v repozitáři: ",
paste(neexistujici, collapse = ", "),
call. = FALSE)
}
# vyfiltruje nenainstalované balíčky
not_installed <- kniha[!(kniha %in% installed.packages()[, "Package"])]
if (length(not_installed) > 0) {
cat("Not installed packages:\n")
cat(paste("-", not_installed), sep = "\n")
cat("Install them now?? [y/n]: ")
response <- tolower(readline())
if (!response %in% c("y", "yes")) {
return(cat("Cancelled.\n"))
}
install.packages(not_installed, dependencies = TRUE)
}
# načte všechny balíčky
for (kapitola in kniha) {
suppressPackageStartupMessages(library(kapitola, character.only = TRUE))
cat("DONE", kapitola, "\n")
}
}
knihovnik(terra, dplyr, xxs)
knihovnik <- function(...) {
# převezme jména balíčků jako text
kniha <- as.character(substitute(list(...)))[-1L]
# zjistí, které balíčky na CRAN vůbec existují
dostupne <- rownames(available.packages())
neexistujici <- kniha[!(kniha %in% dostupne)]
# upozorní na neexistující balíčky a vynechá je
if (length(neexistujici) > 0) {
warning("Tyto balíčky neexistují a budou přeskočeny: ",
paste(neexistujici, collapse = ", "),
call. = FALSE)
kniha <- setdiff(kniha, neexistujici)
}
# vyfiltruje nenainstalované balíčky
not_installed <- kniha[!(kniha %in% installed.packages()[, "Package"])]
if (length(not_installed) > 0) {
cat("Not installed packages:\n")
cat(paste("-", not_installed), sep = "\n")
cat("Install them now?? [y/n]: ")
response <- tolower(readline())
if (!response %in% c("y", "yes")) {
return(cat("Cancelled.\n"))
}
install.packages(not_installed, dependencies = TRUE)
}
# načte všechny balíčky
for (kapitola in kniha) {
suppressPackageStartupMessages(library(kapitola, character.only = TRUE))
cat("DONE", kapitola, "\n")
}
}
knihovnik(terra, dplyr, xxs)
knihovnik("terra", dplyr, xxs)
knihovnik(c("terra", "dplyr", "xxs"))
knihovnik <- function(...) {
# take input as a string, drop "list"
kniha <- as.character(substitute(list(...)))[-1L]
# check if those exists !! this only searches for packages on CRAN !!
available <- rownames(available.packages())
nonexist <- kniha[!(kniha %in% available)]
# return warning for nonexisting packages
if (length(nonexist) > 0) {
warning("Those packages likely dont exist, they will be skiped: ",
paste(nonexist, collapse = ", "),
call. = FALSE)
kniha <- setdiff(kniha, nonexist)
}
# noninstalled packages
not_installed <- kniha[!(kniha %in% installed.packages()[, "Package"])]
if (length(not_installed) > 0) {
cat("Not installed packages:\n")
cat(paste("-", not_installed), sep = "\n")
cat("Install them now?? [y/n]: ")
response <- tolower(readline())
if (!response %in% c("y", "yes")) {
return(cat("Cancelled.\n"))
}
install.packages(not_installed, dependencies = TRUE)
}
# load packages
for (kapitola in kniha) {
suppressPackageStartupMessages(library(kapitola, character.only = TRUE))
cat("DONE", kapitola, "\n")
}
}
knihovnik(terra, dplyr, xxs)
knihovnik("terra", "dplyr", "xxs", blbostiiiii)
