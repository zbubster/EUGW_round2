source("scripts/knihovnik.R")
knihovnik(c("terra", "sf", "caret", "pROC"))
pred_2023 <- rast("Milovice_Mlada/EUGW_data/CZ_CON_CON_75111_20230101_20231231_GTYH_CLASS.tif")
pred_2023
table(pred_2023)
valid_2025 <- vect("Milovice_Mlada/export.gpkg")
plot(pred_2023)
plot(valid_2025, add = T)
plot(valid_2025, add = T, cex = 2)
plot(valid_2025)
valid_2025
valid_2025
valid_2025 <- vect("Milovice_Mlada/export.gpkg")
valid_2025
source("scripts/CRS.R")
check_same_crs(pred_2023)
check_same_crs(pred_2023, valid_2025)
check_same_crs(c(pred_2023, valid_2025))
check_same_crs(list(pred_2023, valid_2025))
check_same_crs(list(pred_2023, valid_2025))
source("scripts/knihovnik.R")
source("scripts/CRS.R")
harmonize_crs(list(pred_2023, valid_2025))
check_same_crs(list(pred_2023, valid_2025))
laylist <- harmonize_crs(list(pred_2023, valid_2025))
check_same_crs(laylist)
pred_2023 <- laylist[[pred_2023]]
pred_2023 <- laylist[["pred_2023"]]
pred_2023
laylist
pred_2023 <- laylist[[1]]
pred_2023
valid_2025 <- laylist[[2]]
plot(pred_2023)
plot(valid_2025)
plot(pred_2023)
plot(valid_2025, add = T)
## buffer and crop rasters
buff <- vect("data/evl_buff1000.gpkg")
plot(buff, add = T)
?project
buff <- project(buff, crs(pred_2023))
plot(buff, add = T)
?crop
buff
buffMM <- buff[,KOD == 2567]
buffMM <- buff[,buff$KOD == 2567]
buffMM
buff[,buff$KOD == 2567]
buff[buff$KOD == 2567]
buff[buff$KOD == 2567]
buffP <- buff[buff$SITECODE == "CZ0714077"]
buffMM <- buff[buff$SITECODE == "CZ0214006"]
buffMM
buffP
pred_2023_croped <- crop(pred_2023, buffMM, snap = "in")
plot(pred_2023_croped)
plot(buffMM, add = T)
plot(valid_2025, add = T)
pred_2023_croped <- crop(pred_2023, buffMM, snap = "near")
plot(pred_2023_croped)
pred_2023_croped <- crop(pred_2023, buffMM, snap = "in", mask = T)
plot(pred_2023_croped)
plot(buffMM, add = T)
plot(valid_2025, add = T)
## extract information for validation data sites
data <- extract(c(pred_2023_croped), valid_2025, ID=TRUE)
data
## convert validation data information to grassland type code
GT_char <- c("GT1 - Dry grassland",
"GT2 - Mesic grassland",
"GT3 - Wet and seasonally wet grassland",
"GT4 - Alpine and sub-alpine grassland",
"GT5 - Forest clearings",
"GT6 - Inland salt steppes",
"GT7 - Sparsely wooded grassland"
)
GT_code <- 21:27
## convert validation data information to grassland type code
GT_char <- c("Dry grassland",
"Mesic grassland",
"Wet and seasonally wet grassland",
"Alpine and sub-alpine grassland",
"Forest clearings",
"Inland salt steppes",
"Sparsely wooded grassland"
)
GT_code <- 21:27
GT_char
GT_code
valid_2025$EUNIS_LC
match(valid_2025$EUNIS_LC, GT_char)
valid_2025$code_EUNIS_LC <- GT_code[match(valid_2025$EUNIS_LC, GT_char)]
valid_2025$code_EUNIS_LC
## extract information for validation data sites
data <- extract(c(pred_2023_croped), valid_2025, ID=TRUE)
data <- cbind(data, valid_2025$code_EUNIS_LC)
data
data <- cbind(data, valid = valid_2025$code_EUNIS_LC)
data
## extract information for validation data sites
data <- extract(c(pred_2023_croped), valid_2025, ID=TRUE)
data <- cbind(data, valid = valid_2025$code_EUNIS_LC)
data
cm <- confusionMatrix(
factor(data$predicted_label, levels=21:27),
factor(data$valid, levels=21:27)
)
cm
# AUC for "Dry grasslands"
roc_21 <- roc(data$valid == 21, data$predicted_label)
## load rasters
files_class <- list.files(
path = "Milovice_Mlada/EUGW_data/",
pattern = "CLASS\\.tif$",
full.names = TRUE
)
files_class
rasters <- rast(files_class)
rasters
# rename rasters by years
years <- substr(basename(files_class), 18, 21)
names(rasters) <- years
years
rasters
## stability map
# load rasters
files_class <- list.files(
path = "Milovice_Mlada/EUGW_data/",
pattern = "CLASS\\.tif$",
full.names = TRUE
)
files_class <- sort(files_class)
rasters <- rast(files_class)
# rename rasters by years
years <- substr(basename(files_class), 18, 21)
names(rasters) <- years
## stability
stable <- app(rasters, fun = function(x) all(x == x[1]))
plot(stable, main="Stable (TRUE) vs Changed (FALSE)")
## number of changes through years
nchanges <- app(rasters, fun = function(x) sum(diff(x) != 0))
plot(nchanges, main="Number of changes (2016–2023)")
# crop rasters
rasters <- crop(rasters, buffMM, snap = "in", mask = T)
all_class_rasters <- rast(files_class)
# crop rasters
all_class_rasters <- crop(all_class_rasters, buffMM, snap = "in", mask = T)
# rename rasters by years
years <- substr(basename(files_class), 18, 21)
names(all_class_rasters) <- years
## binary stability ‒ where class does not change through years
stable <- app(all_class_rasters, fun = function(x) all(x == x[1])) # all values same?
plot(stable, main="Stable (TRUE) vs Changed (FALSE)")
## number of changes through years
nchanges <- app(all_class_rasters, fun = function(x) sum(diff(x) != 0))
plot(nchanges, main="Number of changes (2016–2023)")
## modus map ??????? does this heve even hlava and pata ??????
modus <- app(all_class_rasters, fun = function(x) {
ux <- unique(x)
ux[which.max(tabulate(match(x, ux)))]
})
plot(modus, main="Most frequent class per pixel (2016–2023)")
plot(pred_2023_croped)
source("scripts/knihovnik.R")
co <- c(terra, dplyr, stringr, tidyr, networkD3, htmlwidgets)
co <- c("terra", "dplyr", "stringr", "tidyr", "networkD3", "htmlwidgets")
knihovnik(co)
# config
dir <- "Milovice_Mlada/EUGW_data/"
# load resters and sort them
files_class <- list.files(
path = dir,
pattern = "CLASS\\.tif$",
full.names = TRUE
) %>% sort()
if (length(files_class) < 2) stop("ERROR: Less than 2 rasters found. At least 2 needed for transition matrix!")
# extract year from raster file name
extract_year <- function(x) {
m <- str_match(basename(x), "_(\\d{8})_")
if (is.na(m[1,2])) NA_character_ else substr(m[1,2], 1, 4)
}
years <- vapply(files_class, extract_year, character(1))
years
years <- vapply(files_class, extract_year, character(1))
if (any(is.na(years))) stop("For some files year identification failed!")
# create raster stack
r_stack <- rast(files_class)
names(r_stack) <- years
# Kontrola konzistence rastrů (volitelně)
stopifnot(all.equal(ext(r_stack[[1]]), ext(r_stack[[nlayers(r_stack)]])))
stopifnot(all.equal(res(r_stack[[1]]), res(r_stack[[nlayers(r_stack)]])))
# pairwise transition matrix between years
pairwise_list <- vector("list", nlyr(r_stack) - 1)
for (i in 1:(nlyr(r_stack) - 1)) {
r_from <- r_stack[[i]]
r_to   <- r_stack[[i + 1]]
# crosstab; long=TRUE = data.frame s colnames: from, to, Freq
ct <- crosstab(r_from, r_to, long = TRUE)
colnames(ct) <- c("from_class", "to_class", "count")
# Vyhoď NA a nulové počty
ct <- ct %>%
filter(!is.na(from_class), !is.na(to_class), count > 0)
# (volitelné) omezit jen na kategorie 21:27
ct <- ct %>%
filter(from_class %in% 21:27, to_class %in% 21:27)
ct <- ct %>%
mutate(year_from = names(r_stack)[i],
year_to   = names(r_stack)[i + 1])
pairwise_list[[i]] <- ct
}
# pairwise transition matrix between years
pairwise_list <- vector("list", nlyr(r_stack) - 1)
for (i in 1:(nlyr(r_stack) - 1)) {
r_from <- r_stack[[i]]
r_to   <- r_stack[[i + 1]]
# spojíme do dvouvrstvého rastru a pojmenujeme
rr <- c(r_from, r_to)
names(rr) <- c("from_class", "to_class")
# vyexportujeme dvojice hodnot pixelů, bez NA
df <- terra::as.data.frame(rr, na.rm = TRUE)
# omezíme na 21:27 (pokud chceš)
df <- df |>
filter(from_class %in% 21:27, to_class %in% 21:27)
# spočítáme četnosti
ct <- df |>
count(from_class, to_class, name = "count") |>
mutate(year_from = names(r_stack)[i],
year_to   = names(r_stack)[i + 1])
pairwise_list[[i]] <- ct
}
pairwise_list
transitions_df <- bind_rows(pairwise_list)
# --- NODES + LINKS PRO SANKEY ---
nodes <- transitions_df |>
transmute(src = paste0(year_from, "_", from_class),
tgt = paste0(year_to,   "_", to_class)) |>
pivot_longer(everything(), values_to = "name") |>
distinct(name) |>
arrange(name) |>
mutate(id = row_number() - 1) |>
select(name, id)
transitions_df
# --- NODES + LINKS PRO SANKEY ---
# Vytvoř názvy uzlů "YYYY_class"
src_names <- paste0(transitions_df$year_from, "_", transitions_df$from_class)
tgt_names <- paste0(transitions_df$year_to,   "_", transitions_df$to_class)
src_names
tgt_names
# Sjednoť, seřaď (rok, pak třída), očísluj 0-based ID
node_names <- unique(c(src_names, tgt_names))
node_names
nodes <- data.frame(name = node_names, stringsAsFactors = FALSE)
nodes$year  <- as.integer(substr(nodes$name, 1, 4))
nodes$class <- as.integer(sub(".*_(\\d+)$", "\\1", nodes$name))
nodes <- nodes[order(nodes$year, nodes$class), ]
nodes$id <- seq_len(nrow(nodes)) - 1
nodes <- nodes[, c("name", "id")]  # finální tvar pro networkD3
# Zpět namapuj source/target ID do hrany (links)
links <- transitions_df |>
mutate(source_name = paste0(year_from, "_", from_class),
target_name = paste0(year_to,   "_", to_class)) |>
left_join(nodes, by = c("source_name" = "name")) |>
rename(source = id) |>
left_join(nodes, by = c("target_name" = "name")) |>
rename(target = id) |>
transmute(
source, target,
value = count,
year_from, year_to, from_class, to_class
)
links
if (min_count_for_sankey > 0) {
links <- links |> filter(value >= min_count_for_sankey)
}
min_count_for_sankey <- 0
if (min_count_for_sankey > 0) {
links <- links |> filter(value >= min_count_for_sankey)
}
sankey <- sankeyNetwork(
Links = links,
Nodes = nodes,
Source = "source",
Target = "target",
Value  = "value",
NodeID = "name",
fontSize = 12,
nodeWidth = 25,
sinksRight = FALSE
)
sankey
min_count_for_sankey <- 100
if (min_count_for_sankey > 0) {
links <- links |> filter(value >= min_count_for_sankey)
}
sankey <- sankeyNetwork(
Links = links,
Nodes = nodes,
Source = "source",
Target = "target",
Value  = "value",
NodeID = "name",
fontSize = 12,
nodeWidth = 25,
sinksRight = FALSE
)
sankey
# --- NODES + LINKS PRO SANKEY ---
src_names <- paste0(transitions_df$year_from, "_", transitions_df$from_class)
tgt_names <- paste0(transitions_df$year_to,   "_", transitions_df$to_class)
node_names <- unique(c(src_names, tgt_names))
nodes <- data.frame(name = node_names, stringsAsFactors = FALSE)
nodes$year  <- as.integer(substr(nodes$name, 1, 4))
nodes$class <- as.integer(sub(".*_(\\d+)$", "\\1", nodes$name))
# Seřadit: rok vzestupně, třída podle 21..27 (i když některé nemusí být přítomné)
desired_order <- 21:27
nodes$class_rank <- match(nodes$class, desired_order)
nodes <- nodes[order(nodes$year, nodes$class_rank, nodes$class), ]
nodes$id <- seq_len(nrow(nodes)) - 1
nodes$group <- as.factor(nodes$year)  # pro barvy
nodes <- nodes[, c("name", "id", "group")]
# --- LINKS: mapování na ID ---
links <- transitions_df |>
mutate(source_name = paste0(year_from, "_", from_class),
target_name = paste0(year_to,   "_", to_class)) |>
left_join(nodes[, c("name","id")], by = c("source_name" = "name")) |>
rename(source = id) |>
left_join(nodes[, c("name","id")], by = c("target_name" = "name")) |>
rename(target = id) |>
transmute(
source, target,
value = count,
year_from, year_to, from_class, to_class
)
if (min_count_for_sankey > 0) {
links <- links |> filter(value >= min_count_for_sankey)
}
# --- Barevná škála podle roku (doména = unikátní roky) ---
years_vec <- sort(unique(nodes$group))
# vyrobíme JS scale s 8 barvami (případně přidej další)
col_range <- c("#1f77b4","#ff7f0e","#2ca02c","#d62728",
"#9467bd","#8c564b","#e377c2","#7f7f7f")
# když je víc roků než barev, zrecykluje se
colourScale_js <- htmlwidgets::JS(
sprintf(
"d3.scaleOrdinal().domain(%s).range(%s)",
jsonlite::toJSON(as.character(years_vec)),
jsonlite::toJSON(rep(col_range, length.out = length(years_vec)))
)
)
sankey <- sankeyNetwork(
Links = links,
Nodes = nodes,
Source = "source",
Target = "target",
Value  = "value",
NodeID = "name",
fontSize = 12,
nodeWidth = 25,
sinksRight = FALSE
)
sankey
# --- Vykreslení: iterations=0 zachová vstupní pořadí uvnitř sloupce ---
sankey <- networkD3::sankeyNetwork(
Links = links,
Nodes = nodes,
Source = "source",
Target = "target",
Value  = "value",
NodeID = "name",
NodeGroup = "group",       # barvy podle roku
colourScale = colourScale_js,
fontSize = 12,
nodeWidth = 26,
nodePadding = 10,
sinksRight = FALSE,
iterations = 0             # důležité pro zachování pořadí (21:27)
)
# --- Přidat popisky roků nad sloupce (JS po vykreslení) ---
sankey <- htmlwidgets::onRender(
sankey,
"
function(el, x) {
var svg   = d3.select(el).select('svg');
var nodes = d3.select(el).selectAll('.node').data();  // data s pozicemi
if (!nodes || !nodes.length) return;
// Získat unikátní roky a jejich x-pozice (sloupce)
var cols = {};
nodes.forEach(function(d){
var year = d.name.split('_')[0];
if(!cols[year]) cols[year] = [];
cols[year].push(d.x);
});
// Vyrob popisek pro každý rok nad jeho sloupcem (x = min x v daném roce)
Object.keys(cols).sort().forEach(function(year){
var xs = cols[year];
var xMin = d3.min(xs);
// šířka uzlu je d.dx – vezmeme první uzel s daným rokem pro odhad středu
var nd = nodes.find(function(n){ return n.name.indexOf(year + '_') === 0; });
var dx = nd && nd.dx ? nd.dx : 0;
var xCenter = xMin + dx/2 + 2;
svg.append('text')
.attr('x', xCenter)
.attr('y', 14)                 // výška popisku
.attr('text-anchor', 'middle')
.style('font-size', '12px')
.style('font-weight', '600')
.text(year);
});
}
"
)
# Zobrazit a uložit
sankey
